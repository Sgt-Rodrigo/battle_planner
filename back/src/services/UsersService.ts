import { AppDataSource } from "../config/data-source";
import NewUserDTO from "../dto/NewUserDTO";
import UserDTO from "../dto/UserDTO";
import { User } from "../entities/User";
import ILoginResponse from "../interfaces/ILoginResponse";
import IUser from "../interfaces/IUser";
import UserRepository from "../repositories/UserRepository";
import CredentialsService from "./CredentialsService";

//*? instantiates cred service to use methods
const credentialsService = new CredentialsService();

//*? implements a class to encapsulate the mehtods
//*? I don't make them static for future testing purposes
export default class UsersServices {

    //*? returns all users   
   async getUsers():Promise<User[]> {
        const users = await UserRepository.find({
            relations: {
                appointments: true
            }
        });
        return users
    };

    //*? returns 1 user by id.
    async getUserById(id: number):Promise<User> {
      try {
          //*? I tried using findOneBy() but couldn't get the relations so I went with the old reliable friend find().
          const user = await UserRepository.findOne({
              where: { id: id}, 
              relations: {appointments: true}
          })
        
         if(!user) throw new Error(`User Not Found`);

         return user
      } catch (error) {
        throw error
      }
    }

    //*? async functions are typed with Promise<T> return
    async createUser(userData:UserDTO, password:string):Promise<IUser> {

        const queryRunner = AppDataSource.createQueryRunner();
        await queryRunner.connect();

        await queryRunner.startTransaction();

       try {
         const newCredential = await credentialsService.createCredential(userData.usrName, password);
        
         //*! I created an specific DTO for the newUser, UserDTO/User/IUser can not be used here cause they dont match this schemma. 
         const newUser:NewUserDTO= {            
             usrName: userData.usrName,
             email: userData.email,
             birthDate: userData.birthDate,
             nationalId: userData.nationalId, 
             //*? here pass the whole cred object >  dont use newCredential.id > remember typeorm knows it has to look for the primary key in credentials and make the relation to it.
             credential: newCredential,          
         }
 
         //*? for users table creates and save a newUser
         const user = UserRepository.create(newUser);   
         await UserRepository.save(newUser);        
         
         //*? After creating > the data adjusts to User, cause the Id is autogenerated and create returns the resolved entity instance
         return user
       } catch (error) {
        await queryRunner.rollbackTransaction();
        throw error;
       } finally {
        //*! despite of an error being thrown > the finally block will execute anyway, it always does.
        await queryRunner.release();
       }
    };
    

        async loginUser(usrName:string, password:string):Promise<ILoginResponse>{
           try {
             const user = await UserRepository.findOne({
                 where: {usrName:usrName},
                 relations:{
                  credential:true,
                  appointments: true
                }
             });
             console.log(user)
     
             if(!user) throw new Error(`Incorrect Username`);

             //*? compare and verify password match
             if(user.credential.password !== password)
                throw new Error(`Incorrect Password`)
             
             return {
                login: true,
                user: {
                  id: user.id,
                  name: user.usrName,
                  email: user.email,
                  birthdate: user.birthDate,
                  nDni: user.nationalId,
                  appointments: user.appointments
                }
              };

           } catch (error) {
                throw error
           }          
        }

    async deleteUser(id:number){
        // users = users.filter((user:IUser) => user.id !== id)
    };
}