import { AppDataSource } from "../config/data-source";
import UserDTO from "../dto/UserDTO";
import { User } from "../entities/User";
import IUser from "../interfaces/IUser";
import UserRepository from "../repositories/UserRepository";
import CredentialsService from "./CredentialsService";

//*? mock database and id generator
// let users:IUser[]= [
//     {
//         id: 1,
//         usrName: 'Ricky',
//         email: 'ricky@ricky.com',
//         birthDate: '1980-6-13',
//         nationalId: 456, 
//         credentialsId: 15
//     }
// ];

// let id: number = 2;

const credentialsService = new CredentialsService();

//*? implements a class to encapsulate the mehtods
export default class UsersServices {

    //*? return all users
    async getUsers():Promise<User[]> {
        const users = await UserRepository.find({
            relations: {
                appointments: true
            }
        });
        return users
    };

    //*?returns 1 user by id.
    async getUserById(id: number): Promise<User | null> {
        const user = await UserRepository.findOneBy({id});

        // const user = users.find(user => user.id === id);
        // //* ternary to verify if user actually exists
        // return user ? user : null;

        return user
    }

    //*? async functions are typed with Promise<T> return
    async createUser(userData:UserDTO, password:string):Promise<User> {

        const newCredential = await credentialsService.createCredential(userData.usrName, password);
       
        //*? I don't know how I should type this, it's not DTO, it's not interface 
        const newUser = {            
            usrName: userData.usrName,
            email: userData.email,
            birthDate: userData.birthDate,
            nationalId: userData.nationalId, 
            //*? here dont use newCredential.id > remember typeorm knows it has to look for the primary key in credentials and make the relation to it.
            credential: newCredential,          
        }

        //*? for users table creates and save a newUser
        const user = await UserRepository.create(newUser);   
        await UserRepository.save(newUser);
       
        
        //*? After creating > the data adjusts to IUser, cause the Id is autogenerated and create returns the resolved entity instance
        return user
    };
    

    async deleteUser(id:number){
        // users = users.filter((user:IUser) => user.id !== id)
    };
}